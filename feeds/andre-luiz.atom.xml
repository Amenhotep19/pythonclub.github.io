<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>PythonClub</title><link href="http://pythonclub.com.br/" rel="alternate"></link><link href="http://pythonclub.com.br/feeds/andre-luiz.atom.xml" rel="self"></link><id>http://pythonclub.com.br/</id><updated>2015-10-27T02:02:00-02:00</updated><entry><title>Workflow com Git flow</title><link href="http://pythonclub.com.br/workflow-com-git-flow.html" rel="alternate"></link><updated>2015-10-27T02:02:00-02:00</updated><author><name>André Luiz</name></author><id>tag:pythonclub.com.br,2015-10-27:workflow-com-git-flow.html</id><summary type="html">&lt;p&gt;Esse é um artigo rápido que visa descrever como venho trabalhando com o Git Flow, antes de mais nada o Git Flow é uma forma de gerenciar branchs e tags em repositórios Git originalmente descrita &lt;a href="http://nvie.com/posts/a-successful-git-branching-model/"&gt;aqui&lt;/a&gt; e que originou &lt;a href="https://github.com/nvie/gitflow"&gt;uma extensão&lt;/a&gt; para o Git pelo mesmo autor.&lt;/p&gt;
&lt;p&gt;Partindo do principio que você já possui o &lt;code&gt;git-flow&lt;/code&gt; instalado, na raiz do seu repositório use o comando &lt;code&gt;git flow init&lt;/code&gt; para configurar o git flow no seu repositório atual, serão feitas algumas perguntas para as quais eu habitualmente uso sempre a opção default.&lt;/p&gt;
&lt;p&gt;Git flow instalado, configuração já feita, vamos a um &lt;em&gt;how to&lt;/em&gt; de como agir no dia-a-dia.&lt;/p&gt;
&lt;h5&gt;Quero iniciar o desenvolvimento de uma nova feature&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow feature start nome-da-feature
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;O comando acima iria criar uma nova branch chamada &lt;code&gt;feature/nome-da-feature&lt;/code&gt; partindo do conteúdo atual da branch &lt;code&gt;develop&lt;/code&gt;, a partir daqui você deve realizar todo seu trabalho nessa branch que acabou de ser criada.&lt;/p&gt;
&lt;h5&gt;Quero publicar minha feature para outra pessoa mexer ou continuar de outro computador.&lt;/h5&gt;
&lt;p&gt;Antes de mais nada faça commit de todas sua alterações como de costume e então execute o comando abaixo:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow feature publish nome-da-feature
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esse comando simplesmente ira fazer um &lt;code&gt;git push&lt;/code&gt; para o servidor remoto criando a branch caso não exista.&lt;/p&gt;
&lt;p&gt;Então a outra pessoa (ou você mesmo de outro computador) deverá usar o comando abaixo.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow feature pull nome-da-feature
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;Terminei minha feature e agora?&lt;/h5&gt;
&lt;p&gt;Depois de commitar todas sua alterações use o comando:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow feature finish nome-da-feature
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esse comando ira executar um merge da sua feature na branch &lt;code&gt;develop&lt;/code&gt; e então ira remover a branch &lt;code&gt;feature/nome-da-feature&lt;/code&gt; da sua maquina local e do  servidor remoto (e sim, é esse o comportamento desejado, não queremos 200 branchs defasadas depois de alguns meses de projeto e queremos poder eventualmente reutilizar o nome de alguma feature em uma futura melhoria por exemplo).&lt;/p&gt;
&lt;h5&gt;Ok, já tenho todas as minhas features prontas, mergeadas na develop e agora preciso coloca-las no ar.&lt;/h5&gt;
&lt;p&gt;Esse é o momento no qual devemos iniciar a criação de um release, para isso utilize o comando&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow release start 1.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Aonde &lt;code&gt;1.2.0&lt;/code&gt; é o nome do release, a partir desse nome será gerada uma tag ao finalizarmos o release, pode ser usado o nome que você quiser &lt;strong&gt;eu&lt;/strong&gt; me habituei em criar release com usando como nome o número da versão que está indo para o ar baseado sempre no &lt;a href="http://semver.org/lang/pt-BR/"&gt;SemVer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;O comando acima ira criar uma nova branch partindo da &lt;code&gt;develop&lt;/code&gt;, caso você tenha algum ajuste para fazer no seu código essa é a hora.&lt;/p&gt;
&lt;h5&gt;E agora quero validar isso no meu servidor de homologação.&lt;/h5&gt;
&lt;p&gt;Eu particularmente não gosto de criar uma tag nova cada vez que algo vai ser homologado, então o que faço é o seguinte:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow release publish 1.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para que o release em andamento seja enviado para o servidor remoto, então no meu servidor de homologação eu executo os seguintes comandos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote update
&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout feature/1.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Caso note que algo precise de ajustes os realizo na minha maquina local, faço um novo publish e então no servidor:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git pull
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;Está tudo OK e agora?&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow release finish 1.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nesse momento será feito merge do release na &lt;code&gt;master&lt;/code&gt; na &lt;code&gt;develop&lt;/code&gt;, tanto as branchs locais quanto remotas usadas pelo release serão deletas, e uma tag com o nome do release será gerada.&lt;/p&gt;
&lt;p&gt;Então esse é o momento de enviarmos todas essas alterações para o servidor remoto:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout master
&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin master

&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout develop
&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin develop

&lt;span class="nv"&gt;$ &lt;/span&gt;git push --tag
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Com isso finalizamos um release utilizan... espera aí, tem mais.&lt;/p&gt;
&lt;h5&gt;Preciso fazer deploy disso agora!&lt;/h5&gt;
&lt;p&gt;No seu servidor de produção baixe a tag nova.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git remote update
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E então altere sua branch atual para a tag da versão que será feita o deploy&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout 1.2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pronto, deploy finalizado.&lt;/p&gt;
&lt;h5&gt;Calma aí, alguma coisa quebrou!!&lt;/h5&gt;
&lt;p&gt;Nesse momento você deve iniciar um hotfix, o hotfix é bem parecido com o release com o porem que ele sempre parte da &lt;code&gt;master&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow hotfix start 1.2.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para o hotfix eu utilizo o mesmo principio de nomes do release, no exemplo acima será criada uma branch com o nome &lt;code&gt;hotfix/1.2.1&lt;/code&gt; que pode ser testada em homologação usando a mesma estratégia que mostramos anteriormente para o release.&lt;/p&gt;
&lt;p&gt;Para finalizar utilize o comando&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow hotfix finish 1.2.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nesse momento será feito merge na &lt;code&gt;master&lt;/code&gt; e &lt;code&gt;develop&lt;/code&gt;, serão apagada as branchs locais e remotas e uma tag com o nome do hotfix será criada, não esqueça de fazer push das branchs e tag, e então você poderá fazer deploy disso da mesma forma que fizemos com o release.&lt;/p&gt;
&lt;h2&gt;Dicas&lt;/h2&gt;
&lt;h5&gt;Desative o &lt;code&gt;fast-forward&lt;/code&gt; para os merges.&lt;/h5&gt;
&lt;p&gt;Assim você não perde o tracking dos merges no &lt;code&gt;git log&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git config --global --add merge.ff &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;Por algum motivo bizarro não quero que as branchs aonde as features são desenvolvidas sejam deletas.&lt;/h5&gt;
&lt;p&gt;Ok... você que manda, utilize para isso a flag &lt;code&gt;-k&lt;/code&gt; no finish&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git flow feature finish -k nome-da-feature
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;Instale o utilize o &lt;code&gt;gitk&lt;/code&gt; para entender melhor aonde começa e termina uma branch e evitar se perder.&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install gitk

&lt;span class="nv"&gt;$ &lt;/span&gt;gitk --all
&lt;/pre&gt;&lt;/div&gt;</summary><category term="desenvolvimento"></category></entry><entry><title>Usando virtualenv com virtualenvwrapper</title><link href="http://pythonclub.com.br/usando-virtualenv-com-virtualenvwrapper.html" rel="alternate"></link><updated>2015-09-09T17:49:00-03:00</updated><author><name>André Luiz</name></author><id>tag:pythonclub.com.br,2015-09-09:usando-virtualenv-com-virtualenvwrapper.html</id><summary type="html">&lt;p&gt;O uso do &lt;code&gt;virtualenv&lt;/code&gt; é um item quase que obrigatório em qualquer ambiente de desenvolvimento Python, é usado para manter pacotes (biblioteca Python) de diferentes projetos independentes e isolados dos pacotes do sistema.&lt;/p&gt;
&lt;p&gt;O que vejo poucas pessoas usando é o &lt;code&gt;virtualenvwrapper&lt;/code&gt; que visa a resolver vários problemas criados pelo &lt;code&gt;virtualenv&lt;/code&gt; como a necessidade de se usar sempre &lt;code&gt;source bin/activate&lt;/code&gt; e os arquivos do &lt;code&gt;virtualenv&lt;/code&gt; sendo colocados lado-a-lado com os arquivos do seu projeto.&lt;/p&gt;
&lt;h2&gt;Instalação&lt;/h2&gt;
&lt;p&gt;Primeiro vamos a instalação dos pacotes necessários (essa possivelmente deverá ser a ultima vez que você instala algo globalmente no seu sistema):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install -H virtualenv virtualenvwrapper
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E adicione a seguinte linha ao final do seu arquivo &lt;code&gt;.bashrc&lt;/code&gt; (ou equivalente):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;source /usr/local/bin/virtualenvwrapper.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Reinicie seu shell e você possuirá entre outros os seguintes novos comandos.&lt;/p&gt;
&lt;h2&gt;Uso&lt;/h2&gt;
&lt;p&gt;Para criar um novo ambiente use:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; mkvirtualenv meu_projeto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para criar um novo ambiente com Python 3:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; mkvirtualenv meu_projeto2 --python=`which python3`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para listar todos seus ambientes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;lsvirtualenv
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para executar um comando em todos os ambientes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;allvirtualenv pip install -U django
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E para remover um ambiente:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rmvirtualenv meu_projeto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E para ativar/trocar de ambiente:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;workon meu_projeto2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para desativar é igual, sem qualquer novidade:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;deactivate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para lista completa de comandos visite a &lt;a href="https://virtualenvwrapper.readthedocs.org/en/latest/command_ref.html"&gt;documentação oficial do virtualenvwrapper&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Dicas&lt;/h2&gt;
&lt;p&gt;Caso você esteja usando o &lt;code&gt;zsh&lt;/code&gt; como shell juntamente com o &lt;code&gt;oh-my-zsh&lt;/code&gt; é possivel ativar automaticamente um ambiente ao entrar em determinadas pastas (&lt;code&gt;cd meu_projeto&lt;/code&gt;) para isso adicione o plugin &lt;code&gt;virtualenvwrapper&lt;/code&gt; a lista de plugins no seu arquivo &lt;code&gt;.zshrc&lt;/code&gt; e sempre que você entrar em alguma pasta o plugin irá procurar um ambiente com o nome daquela pasta e ativa-lo, também é possivel criar um arquivo chamado &lt;code&gt;.venv&lt;/code&gt; dentro da pasta do projeto contendo o nome do ambiente a ser ativado (ex.: &lt;code&gt;echo meu_projeto &amp;gt; .venv&lt;/code&gt;).&lt;/p&gt;</summary><category term="python"></category><category term="desenvolvimento"></category></entry></feed>